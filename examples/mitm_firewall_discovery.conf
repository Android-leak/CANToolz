; Loading modules

; First let's load Hardware device, that connected to target CAN BUS  1
[hw_USBtin]
port = auto         ; Serial port
debug = 1           ; debug level (default 0)
speed = 500         ; bus speed (500, 1000)
bus = 61

; Load second device for mitm, connected to target CAN BUS 2  (do not forget about CAN bus termination!)
[hw_USBtin~1]
port = auto         ; Serial port
debug = 1           ; debug level (default 0)
speed = 500         ; bus speed (500, 1000)
bus = 62

; Load firewall module.
[mod_firewall]     

; Load stat module.
[mod_uniqPrint] 

; Now let's describe the logic of this test and MITM example
[MITM]

hw_USBtin = {'action':'read'}                ; Read packet from CAN BUS 1 (into pipe 1, by default)
hw_USBtin~1 = {'action':'read','pipe':2}     ; Read packet from CAN BUS 2 (into pipe 1)

mod_firewall = {'pipe':1,'black_list':[]}    ; Block some ID (no IDs for beginning)
mod_uniqPrint = {}                           ; let's read statistic from pipe 1

hw_USBtin!1 = {'action':'write','pipe':2}       ; Write packets  to CAN BUS 2 from pipe 2  
hw_USBtin~1!1 = {'action':'write','pipe':1}    ; Write packets  to CAN BUS 2 (which are not blocked from pipe 1)  

; P.S (here '!1' used for hack for pyhton  configparser hack.. temporary.. possible, maybe not)


;;;;;;; let's see how it looks like from console...
; > python cansploit.py -c can_firewall_discovery.py
; hw_USBtin: Port found: COM14
; hw_USBtin: PORT: COM14
; hw_USBtin: Speed: 500
; hw_USBtin: USBtin device found!
; hw_USBtin: Init phase started...
; hw_USBtin: Error opening port: COM14
; hw_USBtin: Port found: COM13
; hw_USBtin: PORT: COM13
; hw_USBtin: Speed: 500
; hw_USBtin: USBtin device found!
; >> s                              ; start loop
; >> v
; Loaded queue of modules:
; 
; Module hw_USBtin                                {'action': 'read', 'pipe': 1}   Enabled: True
;         ||
;         ||
;         \/
; Module hw_USBtin~1                      {'action': 'read', 'pipe': 2}   Enabled: True
;         ||
;         ||
;         \/
; Module mod_firewall                     {'pipe': 1, 'black_list': []}   Enabled: True
;         ||
;         ||
;         \/
; Module mod_uniqPrint                    {'pipe': 1}                     Enabled: True
;         ||
;         ||
;         \/
; Module hw_USBtin!1                      {'action': 'write', 'pipe': 2}  Enabled: True
;         ||
;         ||
;         \/
; Module hw_USBtin~1!1                    {'action': 'write', 'pipe': 1}  Enabled: True
; >> s                                                     ; Start loop 
;
; >> c mod_uniqPrint p                                     ; print stats of what we have 
;
; BUS     LEN     ID              MESSAGE                 COUNT
; 60      8       276             1122334455667788        321
; 60      8       277             1122334455667788        677
; .......
; ....... here can be a lot of data
; ....... let's do any 'action', that should work.
; ....... then let's choose few ID and add them to the block list of firewall
; >> e mod_firewall {'black_list': [276,277,256,122,33,11,232]}
; Edited module: mod_firewall
; Added  params: {'pipe': 1, 'black_list': [276, 277, 256, 122, 33, 11, 232]}
; ...... Now let's try to repeat action, and see if we can do that... if not, than some of those ID responsible for that and that is what we are looking for